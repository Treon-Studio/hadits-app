// Copyright 2023 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
import { lynxUniqueIdAttribute, } from '@lynx-js/web-constants';
import { globalMuteableVars } from '@lynx-js/web-constants';
import { createMainThreadLynx } from './MainThreadLynx.js';
import { initializeElementCreatingFunction } from './elementAPI/elementCreating/elementCreatingFunctions.js';
import { createAttributeAndPropertyFunctions } from './elementAPI/attributeAndProperty/attributeAndPropertyFunctions.js';
import * as domTreeApis from './elementAPI/domTree/domTreeFunctions.js';
import { createEventFunctions } from './elementAPI/event/eventFunctions.js';
import { createStyleFunctions } from './elementAPI/style/styleFunctions.js';
import { flattenStyleInfo, genCssContent, genCssInJsInfo, transformToWebCss, } from './utils/processStyleInfo.js';
import { createExposureService } from './utils/createExposureService.js';
export const elementToRuntimeInfoMap = Symbol('elementToRuntimeInfoMap');
export const getElementByUniqueId = Symbol('getElementByUniqueId');
export const updateCSSInJsStyle = Symbol('updateCSSInJsStyle');
export const lynxUniqueIdToElement = Symbol('lynxUniqueIdToElement');
export const switchExposureService = Symbol('switchExposureService');
export class MainThreadRuntime {
    config;
    /**
     * @private
     */
    [lynxUniqueIdToElement] = [];
    /**
     * @private
     */
    [switchExposureService];
    /**
     * @private
     */
    _lynxUniqueIdToStyleSheet = [];
    /**
     * @private
     */
    _page;
    /**
     * @private the CreatePage will append it to this
     */
    _rootDom;
    /**
     * @private
     */
    _timingFlags = [];
    /**
     * @private
     */
    [elementToRuntimeInfoMap] = new WeakMap();
    constructor(config) {
        this.config = config;
        this.__globalProps = config.globalProps;
        this.lynx = createMainThreadLynx(config, this);
        /**
         * now create the style content
         * 1. flatten the styleInfo
         * 2. transform the styleInfo to web css
         * 3. generate the css in js info
         * 4. create the style element
         * 5. append the style element to the root dom
         */
        flattenStyleInfo(this.config.styleInfo);
        transformToWebCss(this.config.styleInfo);
        const cssInJsInfo = this.config.pageConfig.enableCSSSelector
            ? {}
            : genCssInJsInfo(this.config.styleInfo);
        this._rootDom = this.config.docu.createElement('div');
        const cardStyleElement = this.config.docu.createElement('style');
        cardStyleElement.innerHTML = genCssContent(this.config.styleInfo, this.config.pageConfig);
        this._rootDom = this.config.docu;
        this._rootDom.append(cardStyleElement);
        /**
         * now create Element PAPIs
         */
        Object.assign(this, createAttributeAndPropertyFunctions(this), domTreeApis, createEventFunctions(this), createStyleFunctions(this, cssInJsInfo), initializeElementCreatingFunction(this));
        this._ReportError = this.config.callbacks._ReportError;
        this.__OnLifecycleEvent = this.config.callbacks.__OnLifecycleEvent;
        /**
         * Start the exposure service
         */
        this[switchExposureService] =
            createExposureService(this).switchExposureService;
        /**
         * to know when the main thread is ready
         */
        Object.defineProperty(this, 'renderPage', {
            get: () => {
                return this.#renderPage;
            },
            set: (val) => {
                this.#renderPage = val;
                queueMicrotask(this.config.callbacks.mainChunkReady);
            },
        });
        for (const nm of globalMuteableVars) {
            Object.defineProperty(this, nm, {
                get: () => {
                    return this.__lynxGlobalBindingValues[nm];
                },
                set: (v) => {
                    this.__lynxGlobalBindingValues[nm] = v;
                    this._updateVars?.();
                },
            });
        }
    }
    /**
     * @private
     */
    [getElementByUniqueId](uniqueId) {
        return this[lynxUniqueIdToElement][uniqueId]?.deref();
    }
    [updateCSSInJsStyle](uniqueId, newStyles) {
        let currentElement = this._lynxUniqueIdToStyleSheet[uniqueId]?.deref();
        if (!currentElement) {
            currentElement = this.config.docu.createElement('style');
            this._lynxUniqueIdToStyleSheet[uniqueId] = new WeakRef(currentElement);
            this._rootDom.append(currentElement);
        }
        currentElement.innerHTML =
            `[${lynxUniqueIdAttribute}="${uniqueId}"]{${newStyles}}`;
    }
    /**
     * @private
     */
    __lynxGlobalBindingValues = {};
    get globalThis() {
        return this;
    }
    lynx;
    __globalProps;
    processData;
    #renderPage;
    _ReportError;
    __OnLifecycleEvent;
    __LoadLepusChunk = (path) => {
        try {
            this.lynx.requireModule(path);
            return true;
        }
        catch {
        }
        return false;
    };
    __FlushElementTree = (_subTree, options) => {
        const timingFlags = this._timingFlags;
        this._timingFlags = [];
        if (this._page && !this._page.parentElement) {
            this._rootDom.append(this._page);
        }
        this.config.callbacks.flushElementTree(options, timingFlags);
    };
    updatePage;
    _updateVars;
}
//# sourceMappingURL=MainThreadRuntime.js.map