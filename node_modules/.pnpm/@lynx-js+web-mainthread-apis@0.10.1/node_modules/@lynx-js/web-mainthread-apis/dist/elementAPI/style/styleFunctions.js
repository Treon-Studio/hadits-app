// Copyright 2023 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
import { cssIdAttribute } from '@lynx-js/web-constants';
import hyphenateStyleName from 'hyphenate-style-name';
import { queryCSSProperty } from './cssPropertyMap.js';
import { decodeCssInJs } from '../../utils/decodeCssInJs.js';
import { transformInlineStyleString, transfromParsedStyles, } from './transformInlineStyle.js';
import { elementToRuntimeInfoMap, updateCSSInJsStyle, } from '../../MainThreadRuntime.js';
export function createStyleFunctions(runtime, cssInJsInfo) {
    function __AddClass(element, className) {
        const newClassName = ((element.className ?? '') + ' ' + className)
            .trim();
        element.setAttribute('class', newClassName);
        if (!runtime.config.pageConfig.enableCSSSelector) {
            const newStyleStr = decodeCssInJs(newClassName, cssInJsInfo, element.getAttribute(cssIdAttribute));
            runtime[updateCSSInJsStyle](runtime[elementToRuntimeInfoMap].get(element).uniqueId, newStyleStr);
        }
    }
    function __SetClasses(element, classNames) {
        classNames
            ? element.setAttribute('class', classNames)
            : element.removeAttribute('class');
        if (!runtime.config.pageConfig.enableCSSSelector) {
            const newStyleStr = decodeCssInJs(classNames ?? '', cssInJsInfo, element.getAttribute(cssIdAttribute));
            runtime[updateCSSInJsStyle](runtime[elementToRuntimeInfoMap].get(element).uniqueId, newStyleStr ?? '');
        }
    }
    function __GetClasses(element) {
        return (element.className ?? '').split(' ').filter(e => e);
    }
    function __AddInlineStyle(element, key, value) {
        const lynxStyleInfo = queryCSSProperty(Number(key));
        const valueStr = typeof value === 'number' ? value.toString() : value;
        if (!valueStr) { // null or undefined
            element.style.removeProperty(lynxStyleInfo.dashName);
        }
        else {
            const { transformedStyle } = transfromParsedStyles([[
                    lynxStyleInfo.dashName,
                    valueStr,
                ]]);
            for (const [property, value] of transformedStyle) {
                element.style.setProperty(property, value);
            }
        }
    }
    function __SetInlineStyles(element, value) {
        if (!value)
            return;
        const { transformedStyle } = typeof value === 'string'
            ? transformInlineStyleString(value)
            : transfromParsedStyles(Object.entries(value).map(([k, value]) => [
                hyphenateStyleName(k),
                value,
            ]));
        const transformedStyleStr = transformedStyle.map(([property, value]) => `${property}:${value};`).join('');
        element.setAttribute('style', transformedStyleStr);
    }
    function __SetCSSId(elements, cssId) {
        cssId = cssId.toString();
        for (const element of elements) {
            element.setAttribute(cssIdAttribute, cssId);
            if (!runtime.config.pageConfig.enableCSSSelector) {
                const cls = element.getAttribute('class');
                cls && __SetClasses(element, cls);
            }
        }
    }
    return {
        __AddClass,
        __SetClasses,
        __GetClasses,
        __AddInlineStyle,
        __SetInlineStyles,
        __SetCSSId,
    };
}
//# sourceMappingURL=styleFunctions.js.map