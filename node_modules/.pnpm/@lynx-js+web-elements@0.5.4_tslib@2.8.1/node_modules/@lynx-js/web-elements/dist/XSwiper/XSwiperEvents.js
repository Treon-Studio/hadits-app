import { __esDecorate, __runInitializers, __setFunctionName } from "tslib";
/*
// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
*/
import { bindSwitchToEventListener, genDomGetter, } from '@lynx-js/web-elements-reactive';
import { commonComponentEventSetting } from '../common/commonEventInitConfiguration.js';
import { useScrollEnd } from '../common/constants.js';
import { registerEventEnableStatusChangeHandler } from '@lynx-js/web-elements-reactive';
let XSwipeEvents = (() => {
    let _instanceExtraInitializers = [];
    let _private_handleEnableTransitionEvent_decorators;
    let _private_handleEnableTransitionEvent_initializers = [];
    let _private_handleEnableTransitionEvent_extraInitializers = [];
    let _private_enableScrollEventProcessor_decorators;
    let _private_enableScrollEventProcessor_descriptor;
    return class XSwipeEvents {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _private_handleEnableTransitionEvent_decorators = [registerEventEnableStatusChangeHandler('transition')];
            _private_enableScrollEventProcessor_decorators = [registerEventEnableStatusChangeHandler('scrollstart'), registerEventEnableStatusChangeHandler('lynxscrollend'), registerEventEnableStatusChangeHandler('change'), registerEventEnableStatusChangeHandler('change-event-for-indicator')];
            __esDecorate(this, _private_enableScrollEventProcessor_descriptor = { value: __setFunctionName(function (value, eventName) {
                    this
                        .#eventSwitches[eventName] = value;
                    const { lynxscrollend, scrollstart, change } = this.#eventSwitches;
                    const changeEventEnabled = change || lynxscrollend || scrollstart
                        || this.#eventSwitches['change-event-for-indicator'];
                    this.#listeners.forEach((l) => l(changeEventEnabled));
                }, "#enableScrollEventProcessor") }, _private_enableScrollEventProcessor_decorators, { kind: "method", name: "#enableScrollEventProcessor", static: false, private: true, access: { has: obj => #enableScrollEventProcessor in obj, get: obj => obj.#enableScrollEventProcessor }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(null, null, _private_handleEnableTransitionEvent_decorators, { kind: "field", name: "#handleEnableTransitionEvent", static: false, private: true, access: { has: obj => #handleEnableTransitionEvent in obj, get: obj => obj.#handleEnableTransitionEvent, set: (obj, value) => { obj.#handleEnableTransitionEvent = value; } }, metadata: _metadata }, _private_handleEnableTransitionEvent_initializers, _private_handleEnableTransitionEvent_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static observedAttributes = [];
        #dom = __runInitializers(this, _instanceExtraInitializers);
        #current = 0;
        #pervScrollPosition = 0;
        #dragging = false;
        #debounceScrollForMockingScrollEnd;
        #scrollStarted = false;
        constructor(dom) {
            this.#dom = dom;
        }
        #getContentContainer = genDomGetter(() => this.#dom.shadowRoot, '#content').bind(this);
        #handleEnableTransitionEvent = __runInitializers(this, _private_handleEnableTransitionEvent_initializers, bindSwitchToEventListener(this.#getContentContainer, 'scroll', this.#scrollEventListenerForTransition, { passive: true }));
        #handleScroll() {
            if (!useScrollEnd) {
                // debounce
                clearTimeout(this.#debounceScrollForMockingScrollEnd);
                this.#debounceScrollForMockingScrollEnd = setTimeout(() => {
                    this.#handleScrollEnd();
                }, 100);
            }
            if (!this.#scrollStarted) {
                this.#dom.dispatchEvent(new CustomEvent('scrollstart', {
                    ...commonComponentEventSetting,
                    detail: {
                        current: this.#current,
                        isDragged: this.#dragging,
                    },
                }));
                this.#scrollStarted = true;
            }
            const contentContainer = this.#getContentContainer();
            const isVertical = this.#dom.isVertical;
            /* already scrolled distance */
            const currentScrollDistance = isVertical
                ? contentContainer.scrollTop
                : contentContainer.scrollLeft;
            const pageLength = isVertical
                ? contentContainer.clientHeight
                : contentContainer.clientWidth;
            const totalScrollDistance = isVertical
                ? contentContainer.scrollHeight
                : contentContainer.scrollWidth;
            if (Math.abs(this.#pervScrollPosition - currentScrollDistance)
                > pageLength / 4
                || currentScrollDistance < 10
                || Math.abs(currentScrollDistance - totalScrollDistance) <= pageLength) {
                const current = this.#dom.current;
                if (current !== this.#current) {
                    this.#dom.dispatchEvent(new CustomEvent('change', {
                        ...commonComponentEventSetting,
                        detail: {
                            current,
                            isDragged: this.#dragging,
                        },
                    }));
                    this.#current = current;
                }
                this.#pervScrollPosition = currentScrollDistance;
            }
        }
        #handleScrollEnd() {
            this.#dom.dispatchEvent(new CustomEvent('lynxscrollend', {
                ...commonComponentEventSetting,
                detail: {
                    current: this.#current,
                },
            }));
            this.#scrollStarted = false;
        }
        #handleTouchStart() {
            this.#dragging = true;
        }
        #handleTouchEndAndCancel() {
            this.#dragging = false;
        }
        #scrollEventListenerForTransition() {
            this.#dom.dispatchEvent(new CustomEvent('transition', {
                ...commonComponentEventSetting,
                detail: {
                    dx: this.#getContentContainer().scrollLeft,
                    dy: this.#getContentContainer().scrollTop,
                },
            }));
        }
        #listeners = (__runInitializers(this, _private_handleEnableTransitionEvent_extraInitializers), [
            bindSwitchToEventListener(this.#getContentContainer, 'scroll', this.#handleScroll.bind(this), { passive: true }),
            bindSwitchToEventListener(this.#getContentContainer, 'touchstart', this.#handleTouchStart.bind(this), { passive: true }),
            bindSwitchToEventListener(this.#getContentContainer, 'touchend', this.#handleTouchEndAndCancel.bind(this), { passive: true }),
            bindSwitchToEventListener(this.#getContentContainer, 'touchcancel', this.#handleTouchEndAndCancel.bind(this), { passive: true }),
            bindSwitchToEventListener(this.#getContentContainer, 'scrollend', this.#handleScrollEnd.bind(this), { passive: true }),
        ]);
        #eventSwitches = {
            scrollstart: false,
            lynxscrollend: false,
            change: false,
            'change-event-for-indicator': false,
        };
        get #enableScrollEventProcessor() { return _private_enableScrollEventProcessor_descriptor.value; }
        connectedCallback() {
            this.#current = parseFloat(this.#dom.getAttribute('current') ?? '0');
            const isVertical = this.#dom.isVertical;
            this.#pervScrollPosition = isVertical
                ? this.#getContentContainer().scrollTop
                : this.#getContentContainer().scrollLeft;
        }
    };
})();
export { XSwipeEvents };
//# sourceMappingURL=XSwiperEvents.js.map