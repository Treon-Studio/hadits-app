import { __esDecorate, __runInitializers, __setFunctionName } from "tslib";
/*
// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
*/
import { genDomGetter, } from '@lynx-js/web-elements-reactive';
import { commonComponentEventSetting } from '../common/commonEventInitConfiguration.js';
import { useScrollEnd } from '../common/constants.js';
import { registerEventEnableStatusChangeHandler } from '@lynx-js/web-elements-reactive';
let XViewpagerNgEvents = (() => {
    let _instanceExtraInitializers = [];
    let _private_enableChangeEvent_decorators;
    let _private_enableChangeEvent_descriptor;
    let _private_enableOffsetChangeEvent_decorators;
    let _private_enableOffsetChangeEvent_descriptor;
    return class XViewpagerNgEvents {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _private_enableChangeEvent_decorators = [registerEventEnableStatusChangeHandler('change')];
            _private_enableOffsetChangeEvent_decorators = [registerEventEnableStatusChangeHandler('offsetchange')];
            __esDecorate(this, _private_enableChangeEvent_descriptor = { value: __setFunctionName(function (status) {
                    this.#enableChange = status;
                    this.#enableScrollEventListener();
                }, "#enableChangeEvent") }, _private_enableChangeEvent_decorators, { kind: "method", name: "#enableChangeEvent", static: false, private: true, access: { has: obj => #enableChangeEvent in obj, get: obj => obj.#enableChangeEvent }, metadata: _metadata }, null, _instanceExtraInitializers);
            __esDecorate(this, _private_enableOffsetChangeEvent_descriptor = { value: __setFunctionName(function (status) {
                    this.#enableChange = status;
                    this.#enableScrollEventListener();
                }, "#enableOffsetChangeEvent") }, _private_enableOffsetChangeEvent_decorators, { kind: "method", name: "#enableOffsetChangeEvent", static: false, private: true, access: { has: obj => #enableOffsetChangeEvent in obj, get: obj => obj.#enableOffsetChangeEvent }, metadata: _metadata }, null, _instanceExtraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static observedAttributes = [];
        #dom = __runInitializers(this, _instanceExtraInitializers);
        #isDragging = false;
        #connected = false;
        #currentIndex = 0;
        #debounceScrollForMockingScrollEnd;
        constructor(dom) {
            this.#dom = dom;
        }
        #getScrollContainer = genDomGetter(() => this.#dom.shadowRoot, '#content');
        #scrollHandler = () => {
            if (!this.#connected)
                return;
            const scrollContainer = this.#getScrollContainer();
            const oneItemWidth = this.#dom.clientWidth;
            const scrollLeft = scrollContainer.scrollLeft;
            const innerOffset = scrollLeft / oneItemWidth;
            if (this.#enableChange && !useScrollEnd) {
                // debounce
                clearTimeout(this.#debounceScrollForMockingScrollEnd);
                this.#debounceScrollForMockingScrollEnd = setTimeout(() => {
                    this.#scrollEndHandler();
                }, 100);
            }
            this.#dom.dispatchEvent(new CustomEvent('offsetchange', {
                ...commonComponentEventSetting,
                detail: { offset: innerOffset },
            }));
        };
        #scrollEndHandler = () => {
            if (this.#connected) {
                const scrollContainer = this.#getScrollContainer();
                const oneItemWidth = this.#dom.clientWidth;
                const scrollLeft = scrollContainer.scrollLeft;
                const currentIndex = Math.floor(scrollLeft / oneItemWidth);
                if (currentIndex !== this.#currentIndex) {
                    this.#dom.dispatchEvent(new CustomEvent('change', {
                        ...commonComponentEventSetting,
                        detail: { index: currentIndex, isDragged: this.#isDragging },
                    }));
                    this.#currentIndex = currentIndex;
                }
            }
        };
        #touchStartHandler = () => {
            this.#isDragging = true;
        };
        #touchEndHandler = () => {
            this.#isDragging = false;
        };
        #enableChange = false;
        get #enableChangeEvent() { return _private_enableChangeEvent_descriptor.value; }
        #enableOffsetChange = false;
        get #enableOffsetChangeEvent() { return _private_enableOffsetChangeEvent_descriptor.value; }
        #enableScrollEventListener() {
            const scrollContainer = this.#getScrollContainer();
            if (this.#enableOffsetChange || this.#enableChange) {
                scrollContainer.addEventListener('scroll', this.#scrollHandler, {
                    passive: true,
                });
            }
            else {
                scrollContainer.removeEventListener('scroll', this.#scrollHandler);
            }
            if (useScrollEnd && this.#enableChange) {
                scrollContainer.addEventListener('scrollend', this.#scrollEndHandler, {
                    passive: true,
                });
            }
            else {
                scrollContainer.removeEventListener('scrollend', this.#scrollEndHandler);
            }
        }
        connectedCallback() {
            this.#connected = true;
            const scrollContainer = this.#getScrollContainer();
            this.#dom.addEventListener('touchstart', this.#touchStartHandler, {
                passive: true,
            });
            scrollContainer.addEventListener('touchend', this.#touchEndHandler, {
                passive: true,
            });
            scrollContainer.addEventListener('touchcancel', this.#touchEndHandler, {
                passive: true,
            });
        }
        dispose() {
            const scrollContainer = this.#getScrollContainer();
            scrollContainer.removeEventListener('scroll', this.#scrollHandler);
            scrollContainer.removeEventListener('scrollend', this.#scrollEndHandler);
        }
    };
})();
export { XViewpagerNgEvents };
//# sourceMappingURL=XViewpagerNgEvents.js.map