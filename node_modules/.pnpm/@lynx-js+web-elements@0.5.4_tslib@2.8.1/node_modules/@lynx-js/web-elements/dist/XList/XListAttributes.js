import { __esDecorate, __runInitializers } from "tslib";
/*
// Copyright 2024 The Lynx Authors. All rights reserved.
// Licensed under the Apache License Version 2.0 that can be found in the
// LICENSE file in the root directory of this source tree.
*/
import { bindToStyle, boostedQueueMicrotask, registerAttributeHandler, } from '@lynx-js/web-elements-reactive';
let XListAttributes = (() => {
    let _private_handlerStickyOffset_decorators;
    let _private_handlerStickyOffset_initializers = [];
    let _private_handlerStickyOffset_extraInitializers = [];
    let _private_handlerCount_decorators;
    let _private_handlerCount_initializers = [];
    let _private_handlerCount_extraInitializers = [];
    return class XListAttributes {
        static {
            const _metadata = typeof Symbol === "function" && Symbol.metadata ? Object.create(null) : void 0;
            _private_handlerStickyOffset_decorators = [registerAttributeHandler('sticky-offset', true)];
            _private_handlerCount_decorators = [registerAttributeHandler('span-count', true), registerAttributeHandler('column-count', true)];
            __esDecorate(null, null, _private_handlerStickyOffset_decorators, { kind: "field", name: "#handlerStickyOffset", static: false, private: true, access: { has: obj => #handlerStickyOffset in obj, get: obj => obj.#handlerStickyOffset, set: (obj, value) => { obj.#handlerStickyOffset = value; } }, metadata: _metadata }, _private_handlerStickyOffset_initializers, _private_handlerStickyOffset_extraInitializers);
            __esDecorate(null, null, _private_handlerCount_decorators, { kind: "field", name: "#handlerCount", static: false, private: true, access: { has: obj => #handlerCount in obj, get: obj => obj.#handlerCount, set: (obj, value) => { obj.#handlerCount = value; } }, metadata: _metadata }, _private_handlerCount_initializers, _private_handlerCount_extraInitializers);
            if (_metadata) Object.defineProperty(this, Symbol.metadata, { enumerable: true, configurable: true, writable: true, value: _metadata });
        }
        static observedAttributes = [
            'sticky-offset',
            'initial-scroll-index',
            'span-count',
            'column-count',
        ];
        #dom;
        #handlerStickyOffset = __runInitializers(this, _private_handlerStickyOffset_initializers, bindToStyle(() => this.#dom, '--list-item-sticky-offset', (v) => `${parseFloat(v)}px`));
        #handlerCount = (__runInitializers(this, _private_handlerStickyOffset_extraInitializers), __runInitializers(this, _private_handlerCount_initializers, bindToStyle(() => this.#dom, '--list-item-span-count', (v) => `${parseFloat(v)}`)));
        constructor(dom) {
            __runInitializers(this, _private_handlerCount_extraInitializers);
            this.#dom = dom;
        }
        connectedCallback() {
            const initialScrollIndex = this.#dom.getAttribute('initial-scroll-index');
            if (initialScrollIndex !== null) {
                const index = parseFloat(initialScrollIndex);
                const scrollToInitialIndex = () => {
                    if (this.#dom.clientHeight === 0) {
                        // In Safari, there is the potential race condition between the browser's layout and clientWidth calculate.
                        // So, we have to use requestAnimationFrame to ensure that the code runs after the browser's layout.
                        requestAnimationFrame(scrollToInitialIndex);
                    }
                    else {
                        this.#dom.scrollToPosition({ index });
                    }
                };
                // The reason for using microtasks is that the width and height of the child element may not be rendered at this time, so it will not be able to scroll.
                boostedQueueMicrotask(scrollToInitialIndex);
            }
        }
    };
})();
export { XListAttributes };
//# sourceMappingURL=XListAttributes.js.map